{-# OPTIONS --cubical --no-import-sorts --safe #-}
module Cubical.DStructures.Equivalences.GroupSplitEpiAction where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism

open import Cubical.Data.Sigma
open import Cubical.Data.Unit

open import Cubical.Relation.Binary

open import Cubical.Structures.Subtype
open import Cubical.Structures.Group
open import Cubical.Structures.LeftAction
open import Cubical.Structures.Group.Semidirect

open import Cubical.DStructures.Base
open import Cubical.DStructures.Meta.Isomorphism
open import Cubical.DStructures.Structures.Group
open import Cubical.DStructures.Structures.Action

open Kernel
open GroupHom -- such .fun!
open GroupLemmas
open MorphismLemmas

module _ (‚Ñì ‚Ñì' : Level) where
  -- the ùíÆ-iso of the ùíÆ-structures on the type of
  -- group actions and that of split epis
  ùíÆ-Iso-GroupAct-SplitEpi : ùíÆ-iso (ùíÆ-Action ‚Ñì (‚Ñì-max ‚Ñì ‚Ñì')) (ùíÆ-SplitEpi ‚Ñì (‚Ñì-max ‚Ñì ‚Ñì'))

  -- GroupAction ‚Üí Split Epimorphism
  -- Given the action Œ±, form the semidirect product attached to Œ±,
  -- and show that the second projection out of H ‚ãä‚ü® Œ± ‚ü© G‚ÇÄ
  -- is a split epi with section the right inclusion of G‚ÇÄ
  RelIso.fun ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , H) , _Œ±_) , isAct) = ((G‚ÇÄ , H‚ãäG‚ÇÄ) , (Œπ‚ÇÇ Œ± , œÄ‚ÇÇ Œ±)) , œÄ‚ÇÇ-hasSec Œ±
      where
        -- combine the action structure and axioms
        Œ± = groupaction _Œ±_ isAct
        -- semidirect product induced by the action Œ±
        H‚ãäG‚ÇÄ : Group {‚Ñì-max ‚Ñì ‚Ñì'}
        H‚ãäG‚ÇÄ = H ‚ãä‚ü® Œ± ‚ü© G‚ÇÄ
  -- end of RelIso.fun ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , H) , _Œ±_) , isAct)

  -- split epimorphism ‚Üí group action
  RelIso.inv ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , G‚ÇÅ) , (Œπ , œÉ)) , isSplit) = ((G‚ÇÄ , ker-œÉ) , _Œ±_) , isAct
      where
        open GroupNotation‚ÇÄ G‚ÇÄ
        open GroupNotation‚ÇÅ G‚ÇÅ
        open SplitEpiNotation Œπ œÉ isSplit
        open IsGroupAction

        -- G‚ÇÄ will act on ker œÉ
        ker-œÉ : Group {‚Ñì-max ‚Ñì ‚Ñì'}
        ker-œÉ = ker œÉ

        -- notation: group operation of ker œÉ
        _+‚Çñ_ = ker-œÉ ._+_

        -- the left action structure of G‚ÇÄ on ker œÉ
        -- is given by
        -- g Œ± h := Œπg + h - Œπg
        _Œ±_ : LeftActionStructure ‚ü® G‚ÇÄ ‚ü© ‚ü® ker-œÉ ‚ü©
        g Œ± (h , p) = (ig +‚ÇÅ h) -‚ÇÅ ig , q
          where
            ig = ùíæ g
            abstract
              -- proof that (ig +‚ÇÅ h) -‚ÇÅ ig
              -- lies in ker-œÉ
              q = s ((ig +‚ÇÅ h) -‚ÇÅ ig)
                    ‚â°‚ü® œÉ .isHom (ig +‚ÇÅ h) (-‚ÇÅ ig) ‚ü©
                  s (ig +‚ÇÅ h) +‚ÇÄ s (-‚ÇÅ ig)
                     ‚â°‚ü® cong (s (ig +‚ÇÅ h) +‚ÇÄ_)
                             (mapInv œÉ ig) ‚ü©
                  s (ig +‚ÇÅ h) -‚ÇÄ si g
                     ‚â°‚ü® cong (_+‚ÇÄ -‚ÇÄ (s ig))
                             (œÉ .isHom ig h) ‚ü©
                  (si g +‚ÇÄ s h) -‚ÇÄ si g
                      ‚â°‚ü® cong (Œª z ‚Üí ((si g) +‚ÇÄ z) -‚ÇÄ (si g))
                              p ‚ü©
                  ((si g) +‚ÇÄ 0‚ÇÄ) -‚ÇÄ (si g)
                      ‚â°‚ü® cong (_+‚ÇÄ -‚ÇÄ (s ig))
                              (rId‚ÇÄ (s ig)) ‚ü©
                  (si g) -‚ÇÄ (si g)
                     ‚â°‚ü® rCancel‚ÇÄ (si g) ‚ü©
                  0‚ÇÄ ‚àé

        -- proof that the left action structure Œ±
        -- satisfies the group action axioms
        abstract
          isAct : IsGroupAction G‚ÇÄ ker-œÉ _Œ±_
          -- at every g, g Œ±_ is a homomorphism, that is
          -- g Œ± (h + h') ‚â° g Œ± h + g Œ± h'
          isAct .isHom g (h , p) (h' , p') = subtypeWitnessIrrelevance (sg-typeProp œÉ) q
            where
              ig = Œπ .fun g
              -ig = -‚ÇÅ ig
              q = fst (g Œ± ((h , p) +‚Çñ (h' , p')))
                      ‚â°‚ü® refl ‚ü©
                  (ig +‚ÇÅ (h +‚ÇÅ h')) -‚ÇÅ ig
                      ‚â°‚ü® cong (Œª z ‚Üí (ig +‚ÇÅ (z +‚ÇÅ h')) +‚ÇÅ (-‚ÇÅ ig))
                              (sym (rId‚ÇÅ h)
                                ‚àô cong (h +‚ÇÅ_) (sym (lCancel‚ÇÅ ig))) ‚ü©
                  (ig +‚ÇÅ ((h +‚ÇÅ (-ig +‚ÇÅ ig)) +‚ÇÅ h')) -‚ÇÅ ig
                      ‚â°‚ü® cong (Œª z ‚Üí (ig +‚ÇÅ (z +‚ÇÅ h')) -‚ÇÅ ig)
                              (assoc‚ÇÅ h -ig ig) ‚ü©
                  (ig +‚ÇÅ (((h +‚ÇÅ -ig) +‚ÇÅ ig) +‚ÇÅ h')) -‚ÇÅ ig
                      ‚â°‚ü® cong (Œª z ‚Üí (ig +‚ÇÅ z) -‚ÇÅ ig)
                              (sym (assoc‚ÇÅ (h -‚ÇÅ ig) ig h')) ‚ü©
                  (ig +‚ÇÅ ((h +‚ÇÅ -ig) +‚ÇÅ (ig +‚ÇÅ h'))) -‚ÇÅ ig
                      ‚â°‚ü® cong (_+‚ÇÅ -ig)
                              (assoc‚ÇÅ ig (h -‚ÇÅ ig) (ig +‚ÇÅ h')) ‚ü©
                  ((ig +‚ÇÅ (h +‚ÇÅ -ig)) +‚ÇÅ (ig +‚ÇÅ h')) -‚ÇÅ ig
                       ‚â°‚ü® cong (Œª z ‚Üí (z +‚ÇÅ (ig +‚ÇÅ h')) -‚ÇÅ ig)
                               (assoc‚ÇÅ ig h -ig) ‚ü©
                  (((ig +‚ÇÅ h) +‚ÇÅ -ig) +‚ÇÅ (ig +‚ÇÅ h')) -‚ÇÅ ig
                    ‚â°‚ü® sym (assoc‚ÇÅ ((ig +‚ÇÅ h) -‚ÇÅ ig) (ig +‚ÇÅ h') -ig) ‚ü©
                  ((ig +‚ÇÅ h) +‚ÇÅ -ig) +‚ÇÅ ((ig +‚ÇÅ h') +‚ÇÅ -ig)
                       ‚â°‚ü® refl ‚ü©
                  fst ((g Œ± (h , p)) +‚Çñ (g Œ± (h' , p'))) ‚àé
          -- Œ± satisfies the identity law, that is
          -- 0 Œ± h = h for every h
          isAct .identity (h , p) = subtypeWitnessIrrelevance (sg-typeProp œÉ) q
            where
              q = fst (0‚ÇÄ Œ± (h , p))
                      ‚â°‚ü® cong (Œª z ‚Üí (z +‚ÇÅ h) +‚ÇÅ (-‚ÇÅ z))
                              (mapId Œπ) ‚ü©
                  (0‚ÇÅ +‚ÇÅ h) +‚ÇÅ (-‚ÇÅ 0‚ÇÅ)
                    ‚â°‚ü® cong ((0‚ÇÅ +‚ÇÅ h) +‚ÇÅ_)
                            (invId G‚ÇÅ) ‚àô‚àô
                       rId‚ÇÅ (0‚ÇÅ +‚ÇÅ h) ‚àô‚àô
                       lId‚ÇÅ h ‚ü©
                  h ‚àé
          -- Œ± is associative in the sense that
          -- (g +‚ÇÄ g') Œ± h = g Œ± (g' Œ± h)
          isAct .assoc g g' (h , p) = subtypeWitnessIrrelevance (sg-typeProp œÉ) q
            where
              ig = Œπ .fun g
              ig' = Œπ .fun g'
              -ig = -‚ÇÅ ig
              -ig' = -‚ÇÅ ig'
              q = (Œπ .fun (g +‚ÇÄ g') +‚ÇÅ h) -‚ÇÅ (Œπ .fun (g +‚ÇÄ g'))
                     ‚â°‚ü® cong (Œª z ‚Üí (z +‚ÇÅ h) -‚ÇÅ z)
                             (Œπ .isHom g g') ‚ü©
                  ((ig +‚ÇÅ ig') +‚ÇÅ h) -‚ÇÅ (ig +‚ÇÅ ig')
                    ‚â°‚ü® cong (((ig +‚ÇÅ ig') +‚ÇÅ h) +‚ÇÅ_)
                            (invDistr G‚ÇÅ ig ig') ‚ü©
                  ((ig +‚ÇÅ ig') +‚ÇÅ h) +‚ÇÅ (-ig' -‚ÇÅ ig)
                    ‚â°‚ü® cong (_+‚ÇÅ (-ig' +‚ÇÅ -ig))
                            (sym (assoc‚ÇÅ ig ig' h)) ‚ü©
                  (ig +‚ÇÅ (ig' +‚ÇÅ h)) +‚ÇÅ (-ig' -‚ÇÅ ig)
                    ‚â°‚ü® assoc‚ÇÅ (ig +‚ÇÅ (ig' +‚ÇÅ h)) -ig' -ig ‚ü©
                  ((ig +‚ÇÅ (ig' +‚ÇÅ h)) -‚ÇÅ ig') -‚ÇÅ ig
                    ‚â°‚ü® cong (_+‚ÇÅ -ig)
                            (sym (assoc‚ÇÅ ig (ig' +‚ÇÅ h) -ig')) ‚ü©
                  fst (g Œ± (g' Œ± (h , p))) ‚àé
        -- end of abstract
  -- end of RelIso.inv ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , G‚ÇÅ) , (Œπ , œÉ)) , isSplit)

  RelIso.rightInv ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , G‚ÇÅ) , (Œπ , œÉ)) , isSplit) = ((G‚ÇÄ-‚âÖ , G‚ÇÅ-‚âÖ) , Œπ-‚âÖ , œÉ-‚âÖ) , isSplit-‚âÖ
    where
      -- get our hands dirty with shameless reference to what we're constructing,
      -- such is the power of copatterns!
      -- back: turn the given split epi into the group action tuple ga
      ga = RelIso.inv ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , G‚ÇÅ) , (Œπ , œÉ)) , isSplit)
      -- map ga forth to the split epi tuple se'
      se' = RelIso.fun ùíÆ-Iso-GroupAct-SplitEpi ga

      -- notation

      -- short for (ker œÉ) ‚ãä‚ü® Ad·µ¢ ‚ü© G‚ÇÄ
      kœÉ‚ãäG‚ÇÄ = snd (fst (fst se'))
      -- the group action ga
      _Œ±_ = snd (fst ga)
      isAct = snd ga

      open GroupNotation‚ÇÄ G‚ÇÄ
      open GroupNotation‚ÇÅ G‚ÇÅ

      -- notational convention:
      -- g : ‚ü® G‚ÇÄ ‚ü©
      -- h : ‚ü® G‚ÇÅ ‚ü©
      -- p : witness that g is in ker œÉ

      open SplitEpiNotation Œπ œÉ isSplit

      -- G‚ÇÄ ‚âÉ G‚ÇÄ
      G‚ÇÄ-‚âÖ = idGroupEquiv G‚ÇÄ

      -- (ker œÉ) ‚ãä‚ü® Ad·µ¢ ‚ü© G‚ÇÄ ‚âÉ G‚ÇÅ
      G‚ÇÅ-‚âÖ : GroupEquiv kœÉ‚ãäG‚ÇÄ G‚ÇÅ
      GroupEquiv.eq G‚ÇÅ-‚âÖ = isoToEquiv isom
        where
          isom : Iso ‚ü® kœÉ‚ãäG‚ÇÄ ‚ü© ‚ü® G‚ÇÅ ‚ü©
          -- map forth is straight forward
          Iso.fun isom ((h , p) , g) = h +‚ÇÅ ùíæ g

          -- beginning of Iso.inv isom h

          -- G‚ÇÅ part of the map
          fst (fst (Iso.inv isom h)) = h +‚ÇÅ (is- h)
          -- proof that G‚ÇÅ part is in ker œÉ
          snd (fst (Iso.inv isom h)) = q
            where
              abstract
                q = s (h +‚ÇÅ is- h)
                      ‚â°‚ü® œÉ .isHom h (is- h) ‚ü©
                    s h +‚ÇÄ s (is- h)
                      ‚â°‚ü® cong (s h +‚ÇÄ_)
                              (funExt‚Åª (cong GroupHom.fun isSplit) (s- h)) ‚ü©
                    s h +‚ÇÄ (s- h)
                      ‚â°‚ü® cong (s h +‚ÇÄ_)
                              (mapInv œÉ h) ‚ü©
                    s h -‚ÇÄ (s h)
                      ‚â°‚ü® rCancel‚ÇÄ (s h) ‚ü©
                    0‚ÇÄ ‚àé
          -- G‚ÇÄ part of the map
          snd (Iso.inv isom h) = s h

          -- end of Iso.inv isom h

          -- beginning of Iso.leftInv isom ((h , p) , g)

          Iso.leftInv isom ((h , p) , g) = Œ£PathP (subtypeWitnessIrrelevance (sg-typeProp œÉ) q , q')
            where
              abstract
                q = (h +‚ÇÅ ùíæ g) +‚ÇÅ is- (h +‚ÇÅ ùíæ g)
                       ‚â°‚ü® cong (Œª z ‚Üí (h +‚ÇÅ ùíæ g) +‚ÇÅ is z)
                               (invDistr G‚ÇÅ h (ùíæ g)) ‚ü©
                    (h +‚ÇÅ ùíæ g) +‚ÇÅ is ((-i g) -‚ÇÅ h)
                      ‚â°‚ü® cong (Œª z ‚Üí (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ z)
                              (œÉ .isHom (-i g) (-‚ÇÅ h)) ‚ü©
                    (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ ((s-i g) +‚ÇÄ (s- h))
                      ‚â°‚ü® cong (Œª z ‚Üí (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ ((s-i g) +‚ÇÄ z))
                              (mapInv œÉ h ‚àô‚àô
                               cong -‚ÇÄ_ p ‚àô‚àô
                               invId G‚ÇÄ) ‚ü©
                    (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ ((s-i g) +‚ÇÄ 0‚ÇÄ)
                      ‚â°‚ü® cong (Œª z ‚Üí (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ z)
                              (rId‚ÇÄ (s-i g)) ‚ü©
                    (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ (s-i g)
                      ‚â°‚ü® cong (Œª z ‚Üí (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ z )
                              (mapInv œÉ (ùíæ g)) ‚ü©
                    (h +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ (-si g)
                      ‚â°‚ü® cong ((h +‚ÇÅ ùíæ g) +‚ÇÅ_)
                              (mapInv Œπ (si g)) ‚ü©
                    (h +‚ÇÅ ùíæ g) -‚ÇÅ (isi g)
                      ‚â°‚ü® cong (Œª z ‚Üí (h +‚ÇÅ ùíæ g) -‚ÇÅ (ùíæ z))
                              (funExt‚Åª (cong GroupHom.fun isSplit) g ) ‚ü©
                    (h +‚ÇÅ ùíæ g) -‚ÇÅ (ùíæ g)
                      ‚â°‚ü® sym (assoc‚ÇÅ h (ùíæ g) (-i g)) ‚ü©
                    h +‚ÇÅ (ùíæ g -‚ÇÅ (ùíæ g))
                      ‚â°‚ü® cong (h +‚ÇÅ_)
                              (rCancel‚ÇÅ (ùíæ g)) ‚ü©
                    h +‚ÇÅ 0‚ÇÅ
                      ‚â°‚ü® rId‚ÇÅ h ‚ü©
                    h ‚àé

                q' = s (h +‚ÇÅ ùíæ g)
                       ‚â°‚ü® œÉ .isHom h (ùíæ g) ‚ü©
                     s h +‚ÇÄ si g
                       ‚â°‚ü® cong (_+‚ÇÄ si g) p ‚ü©
                     0‚ÇÄ +‚ÇÄ si g
                       ‚â°‚ü® lId‚ÇÄ (si g) ‚ü©
                     si g
                       ‚â°‚ü® funExt‚Åª (cong GroupHom.fun isSplit) g ‚ü©
                     g ‚àé

          -- end of Iso.leftInv isom ((h , p) , g)

          Iso.rightInv isom h = q
            where
              ish = ùíæ (s h)
              abstract
                q = (h +‚ÇÅ ùíæ (s (-‚ÇÅ h))) +‚ÇÅ ish
                       ‚â°‚ü® cong (Œª z ‚Üí (h +‚ÇÅ z) +‚ÇÅ ish) (cong ùíæ (mapInv œÉ h) ‚àô mapInv Œπ (s h)) ‚ü©
                    (h +‚ÇÅ (-‚ÇÅ ish)) +‚ÇÅ ish
                       ‚â°‚ü® sym (assoc‚ÇÅ h (-‚ÇÅ ish) ish) ‚ü©
                    h +‚ÇÅ ((-‚ÇÅ ish) +‚ÇÅ ish)
                       ‚â°‚ü® (cong (h +‚ÇÅ_) (lCancel‚ÇÅ ish)) ‚àô (rId‚ÇÅ h) ‚ü©
                    h ‚àé

          -- end of Iso.rightInv isom h

          -- end of Iso ‚ü® kœÉ‚ãäG‚ÇÄ ‚ü© ‚ü® G‚ÇÅ ‚ü©

      GroupEquiv.isHom G‚ÇÅ-‚âÖ ((h , p) , g) ((h' , p') , g') = q
        where
          abstract
            q = (h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ (-‚ÇÅ ùíæ g))) +‚ÇÅ ùíæ (g +‚ÇÄ g')
                   ‚â°‚ü® cong ((h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ (-‚ÇÅ ùíæ g))) +‚ÇÅ_)
                           (Œπ .isHom g g') ‚ü©
                (h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ (-‚ÇÅ ùíæ g))) +‚ÇÅ (ùíæ g +‚ÇÅ ùíæ g')
                   ‚â°‚ü® sym (assoc‚ÇÅ h ((ùíæ g +‚ÇÅ h') +‚ÇÅ (-‚ÇÅ ùíæ g)) (ùíæ g +‚ÇÅ ùíæ g')) ‚ü©
                h +‚ÇÅ (((ùíæ g +‚ÇÅ h') +‚ÇÅ (-‚ÇÅ ùíæ g)) +‚ÇÅ (ùíæ g +‚ÇÅ ùíæ g'))
                   ‚â°‚ü® cong (h +‚ÇÅ_)
                           (sym (assoc‚ÇÅ (ùíæ g +‚ÇÅ h') (-‚ÇÅ ùíæ g) (ùíæ g +‚ÇÅ ùíæ g'))) ‚ü©
                h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ ((-‚ÇÅ ùíæ g) +‚ÇÅ (ùíæ g +‚ÇÅ ùíæ g')))
                   ‚â°‚ü® cong (Œª z ‚Üí h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ z))
                           (assoc‚ÇÅ (-‚ÇÅ ùíæ g) (ùíæ g) (ùíæ g')) ‚ü©
                h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ (((-‚ÇÅ ùíæ g) +‚ÇÅ ùíæ g) +‚ÇÅ ùíæ g'))
                   ‚â°‚ü® cong (Œª z ‚Üí h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ (z +‚ÇÅ ùíæ g')))
                           (lCancel‚ÇÅ (ùíæ g)) ‚ü©
                h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ (0‚ÇÅ +‚ÇÅ ùíæ g'))
                   ‚â°‚ü® cong (Œª z ‚Üí h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ z))
                           (lId‚ÇÅ (ùíæ g')) ‚ü©
                h +‚ÇÅ ((ùíæ g +‚ÇÅ h') +‚ÇÅ ùíæ g')
                   ‚â°‚ü® cong (h +‚ÇÅ_)
                           (sym (assoc‚ÇÅ (ùíæ g) h' (ùíæ g'))) ‚ü©
                h +‚ÇÅ (ùíæ g +‚ÇÅ (h' +‚ÇÅ ùíæ g'))
                   ‚â°‚ü® assoc‚ÇÅ h (ùíæ g) (h' +‚ÇÅ ùíæ g') ‚ü©
                (h +‚ÇÅ ùíæ g) +‚ÇÅ (h' +‚ÇÅ ùíæ g') ‚àé

      -- end of GroupEquiv kœÉ‚ãäG‚ÇÄ G‚ÇÅ

      Œπ-‚âÖ : (g : ‚ü® G‚ÇÄ ‚ü©) ‚Üí 0‚ÇÅ +‚ÇÅ (ùíæ g) ‚â° ùíæ g
      Œπ-‚âÖ g = lId‚ÇÅ (ùíæ g)

      œÉ-‚âÖ : (((h , _) , g) : ‚ü® kœÉ‚ãäG‚ÇÄ ‚ü©) ‚Üí g ‚â° s (h +‚ÇÅ ùíæ g)
      œÉ-‚âÖ ((h , p) , g) = q
        where
          abstract
            q = g
                  ‚â°‚ü® funExt‚Åª (cong fun (sym isSplit)) g ‚ü©
                s (ùíæ g)
                  ‚â°‚ü® sym (lId‚ÇÄ (s (ùíæ g))) ‚ü©
                0‚ÇÄ +‚ÇÄ s (ùíæ g)
                  ‚â°‚ü® cong (_+‚ÇÄ s (ùíæ g)) (sym p) ‚ü©
                s h +‚ÇÄ s (ùíæ g)
                  ‚â°‚ü® sym (œÉ .isHom h (ùíæ g)) ‚ü©
                s (h +‚ÇÅ ùíæ g) ‚àé

      isSplit-‚âÖ : Unit
      isSplit-‚âÖ = tt

  -- end of RelIso.rightInv ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , G‚ÇÅ) , (Œπ , œÉ)) , isSplit)


  RelIso.leftInv ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , H) , _Œ±_) , isAct) = ((G‚ÇÄ-‚âÖ , H-‚âÖ) , Œ±-‚âÖ) , isAct-‚âÖ
    where
      -- import notation
      open GroupNotation‚ÇÄ G‚ÇÄ
      open GroupNotationH H
      open ActionNotationŒ± (groupaction _Œ±_ isAct) using (Œ±-id)

      se = RelIso.fun ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , H) , _Œ±_) , isAct)
      ga' = RelIso.inv ùíÆ-Iso-GroupAct-SplitEpi se

      -- H under fun and then inv
      ker-œÄ‚ÇÇ = snd (fst (fst ga'))
      -- the adjoint action w.t.r. Œπ‚ÇÇ
      _Œ≤_ = snd (fst ga')
      Œ≤-isAct = snd ga'
      -- inclusion of G‚ÇÄ into H ‚ãä‚ü® Œ± ‚ü© G‚ÇÄ
      Œπ = Œπ‚ÇÇ (groupaction _Œ±_ isAct)
      ùíæ = Œπ .fun

      G‚ÇÄ-‚âÖ : GroupEquiv G‚ÇÄ G‚ÇÄ
      G‚ÇÄ-‚âÖ = idGroupEquiv G‚ÇÄ

      H-‚âÖ : GroupEquiv ker-œÄ‚ÇÇ H
      GroupEquiv.eq H-‚âÖ = isoToEquiv isom
        where
          isom : Iso ‚ü® ker-œÄ‚ÇÇ ‚ü© ‚ü® H ‚ü©
          Iso.fun isom ((h , g) , p) = h
          Iso.inv isom h = (h , 0‚ÇÄ) , refl
          Iso.leftInv isom ((h , g) , p) = q
            where
              abstract
                r : (h , 0‚ÇÄ) ‚â° (h , g)
                r = Œ£PathP (refl , sym p)
                q : ((h , 0‚ÇÄ) , refl) ‚â° ((h , g) , p)
                q = Œ£PathP (r , isProp‚ÜíPathP (Œª i ‚Üí set‚ÇÄ (snd (r i)) 0‚ÇÄ) refl p)
          Iso.rightInv isom h = refl

      GroupEquiv.isHom H-‚âÖ ((h , g) , p) ((h' , g') , p') = q
        where
          abstract
            q : h +·¥¥ (g Œ± h') ‚â° h +·¥¥ h'
            q = h +·¥¥ (g Œ± h')
                  ‚â°‚ü® cong (Œª z ‚Üí h +·¥¥ (z Œ± h')) p ‚ü©
                h +·¥¥ (0‚ÇÄ Œ± h')
                  ‚â°‚ü® cong (h +·¥¥_) (Œ±-id h') ‚ü©
                h +·¥¥ h' ‚àé

      Œ±-‚âÖ : (g : ‚ü® G‚ÇÄ ‚ü©) (((h , g') , p) : ‚ü® ker-œÄ‚ÇÇ ‚ü©)
            ‚Üí GroupEquiv.eq H-‚âÖ .fst (g Œ≤ ((h , g') , p)) ‚â° g Œ± h
      Œ±-‚âÖ g ((h , g') , p) = q
        where
          open ActionLemmas (groupaction _Œ±_ isAct)
          abstract
            q = (0·¥¥ +·¥¥ (g Œ± h)) +·¥¥ ((g +‚ÇÄ g') Œ± ((-‚ÇÄ g) Œ± (-·¥¥ 0·¥¥)))
                  ‚â°‚ü® cong (_+·¥¥ ((g +‚ÇÄ g') Œ± ((-‚ÇÄ g) Œ± (-·¥¥ 0·¥¥))))
                          (lId·¥¥ (g Œ± h)) ‚ü©
                (g Œ± h) +·¥¥ ((g +‚ÇÄ g') Œ± ((-‚ÇÄ g) Œ± (-·¥¥ 0·¥¥)))
                  ‚â°‚ü® cong (Œª z ‚Üí (g Œ± h) +·¥¥ ((g +‚ÇÄ g') Œ± ((-‚ÇÄ g) Œ± z)))
                          (invId H) ‚ü©
                (g Œ± h) +·¥¥ ((g +‚ÇÄ g') Œ± ((-‚ÇÄ g) Œ± 0·¥¥))
                  ‚â°‚ü® cong (Œª z ‚Üí (g Œ± h) +·¥¥ ((g +‚ÇÄ g') Œ± z))
                          (actOnUnit (-‚ÇÄ g)) ‚ü©
                (g Œ± h) +·¥¥ ((g +‚ÇÄ g') Œ± 0·¥¥)
                  ‚â°‚ü® cong ((g Œ± h) +·¥¥_)
                          (actOnUnit (g +‚ÇÄ g')) ‚ü©
                (g Œ± h) +·¥¥ 0·¥¥
                  ‚â°‚ü® rId·¥¥ (g Œ± h) ‚ü©
                g Œ± h ‚àé

      isAct-‚âÖ : Unit
      isAct-‚âÖ = tt
  -- end of RelIso.leftInv ùíÆ-Iso-GroupAct-SplitEpi (((G‚ÇÄ , H) , _Œ±_) , isAct)

  IsoActionSplitEpi : Iso (Action ‚Ñì (‚Ñì-max ‚Ñì ‚Ñì')) (SplitEpi ‚Ñì (‚Ñì-max ‚Ñì ‚Ñì'))
  IsoActionSplitEpi = ùíÆ-iso‚ÜíIso (ùíÆ-Action ‚Ñì (‚Ñì-max ‚Ñì ‚Ñì')) (ùíÆ-SplitEpi ‚Ñì (‚Ñì-max ‚Ñì ‚Ñì')) ùíÆ-Iso-GroupAct-SplitEpi
